<<<<<<< Updated upstream
/*
  Practica 2 - Jenkinsfile dummy (PUNTO DE PARTIDA)

  Este Jenkinsfile es intencionalmente simple. En la Practica 2 iras anadiendo
  piezas (stages, agents, funciones Groovy, Docker build, docker compose, etc.)
  hasta construir un pipeline CI/CD completo.
*/
 
=======
def runInDocker(String image, Closure body) {
  docker.image(image).inside {
    body()
  }
}

def composeUpTestDown(Map args = [:]) {
  try {
    sh args.up
    sh args.test
  } finally {
    sh "${args.down} || true"
  }
}

>>>>>>> Stashed changes
pipeline {
  agent any

  options {
    timestamps()
    disableConcurrentBuilds()
  }

  parameters {
    booleanParam(name: 'RUN_CD', defaultValue: false, description: 'Ejecutar CD (solo develop/master)')
    booleanParam(name: 'ENABLE_REGISTRY_PUSH', defaultValue: false, description: 'Publicar imagen en local-registry')
    booleanParam(name: 'ENABLE_ARTIFACTORY_UPLOAD', defaultValue: false, description: 'Subir JAR a Artifactory')
  }

  environment {
    IMAGE_NAME = 'scalian_training-java-hello-world:0.0.2'
    VERSION_JAR = '0.0.2-SNAPSHOT'
    APP_URL = 'http://localhost:8084/hello'
    REGISTRY = 'local-registry:5000'
    REGISTRY_REPO = 'scalian_training-java-hello-world'
    REGISTRY_CREDS_ID = 'local-registry-creds'
    ARTIFACTORY_URL = 'http://artifactory:8081/artifactory'
    ARTIFACTORY_REPO = 'libs-release-local'
    ARTIFACTORY_CREDS_ID = 'artifactory-creds'
  }

  stages {
    stage('Info') {
      steps {
        echo "Job: ${env.JOB_NAME}"
        echo "Build: ${env.BUILD_NUMBER}"
        echo "Branch: ${env.BRANCH_NAME}"
      }
    }

    stage('CI - Lint') {
      steps {
        script {
          runInDocker('maven:3.8.6-openjdk-11-slim') {
            sh 'make lint'
          }
        }
      }
    }

    stage('CI - Test') {
      steps {
        script {
          runInDocker('maven:3.8.6-openjdk-11-slim') {
            sh 'make test'
          }
        }
      }
    }

    stage('CI - Build image') {
      steps {
        script {
          docker.build(env.IMAGE_NAME, "--build-arg VERSION=${env.VERSION_JAR} -f devops/Dockerfile .")
        }
      }
    }

    stage('CI - Upload jar (opcional)') {
      when {
        expression { return params.ENABLE_ARTIFACTORY_UPLOAD }
      }
      steps {
        script {
          runInDocker('maven:3.8.6-openjdk-11-slim') {
            sh 'mvn -q -DskipTests package'
          }
          withCredentials([usernamePassword(
            credentialsId: env.ARTIFACTORY_CREDS_ID,
            usernameVariable: 'ART_USER',
            passwordVariable: 'ART_PASS'
          )]) {
            sh '''
              JAR_FILE=$(ls target/*.jar | head -n 1)
              ART_PATH="devops-training-java-app/${BUILD_NUMBER}"
              curl -u "${ART_USER}:${ART_PASS}" -T "${JAR_FILE}" \
                "${ARTIFACTORY_URL}/${ARTIFACTORY_REPO}/${ART_PATH}/$(basename ${JAR_FILE})"
            '''
          }
        }
      }
    }

    stage('CI - Push image (opcional)') {
      when {
        expression { return params.ENABLE_REGISTRY_PUSH }
      }
      steps {
        script {
          String registryImage = "${env.REGISTRY}/${env.REGISTRY_REPO}:${env.BUILD_NUMBER}"
          withCredentials([usernamePassword(
            credentialsId: env.REGISTRY_CREDS_ID,
            usernameVariable: 'REG_USER',
            passwordVariable: 'REG_PASS'
          )]) {
            sh """
              echo "\$REG_PASS" | docker login ${env.REGISTRY} -u "\$REG_USER" --password-stdin
              docker tag ${env.IMAGE_NAME} ${registryImage}
              docker push ${registryImage}
            """
          }
        }
      }
    }

    stage('CD') {
      when {
        allOf {
          anyOf {
            branch 'develop'
            branch 'master'
          }
          expression { return params.RUN_CD }
        }
      }
      steps {
        script {
          env.DEPLOY_ENV = (env.BRANCH_NAME == 'master') ? 'PRO' : 'DEV'
          env.COMPOSE_PROJECT = env.DEPLOY_ENV.toLowerCase()
          echo "Deploying to ${env.DEPLOY_ENV}"

          composeUpTestDown(
            up: "docker compose -p ${env.COMPOSE_PROJECT} up -d java_app",
            test: "sleep 5 && curl -fsS ${env.APP_URL}",
            down: "docker compose -p ${env.COMPOSE_PROJECT} down --volumes"
          )
        }
      }
      post {
        always {
          sh "docker rmi ${env.IMAGE_NAME} || true"
        }
        success {
          echo 'SUCCESS'
        }
        failure {
          echo 'FAILURE'
          sh 'docker compose logs || true'
        }
      }
    }
  }
}
