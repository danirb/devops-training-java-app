/*
  Práctica 2 - Jenkinsfile (estructura final / guía)

  Este fichero NO contiene la solución “copiable”.
  Contiene la estructura final que deberías alcanzar tras completar los ejercicios,
  con comentarios indicando qué debes implementar en cada punto.

  Reglas del curso (ver Práctica 2):
  - CI se ejecuta en cualquier rama.
  - CD solo se ejecuta en develop/master y si el parámetro RUN_CD está activado.
*/

// =========================
// Ejercicio 4 (Groovy): función reutilizable
// =========================
def runInDocker(String image, Closure body) {
  // TODO (E4): Ejecuta `body()` dentro del contenedor indicado usando Docker Pipeline:
  // docker.image(image).inside { body() }
}

// =========================
// Ejercicio 9 (opcional): mini “librería” para Compose
// =========================
def composeUpTestDown(Map args = [:]) {
  // TODO (E9): Implementa el flujo:
  // 1) args.up
  // 2) args.test
  // 3) siempre ejecutar args.down (aunque falle)
}

pipeline {
  agent any

  options {
    // Opcional: timestamps() / disableConcurrentBuilds()
  }

  // =========================
  // Ejercicio 6.3 (parámetros)
  // =========================
  parameters {
    // TODO (E6.3): Añade un booleanParam RUN_CD (default false) para habilitar CD.
    // booleanParam(name: 'RUN_CD', defaultValue: false, description: 'Ejecutar CD (solo develop/master)')
  }

  // =========================
  // Ejercicio 6.4 (variables de entorno)
  // =========================
  environment {
    // TODO (E6.4): Define variables reutilizables:
    // - IMAGE_NAME (tag para docker build)
    // - APP_URL (endpoint para e2e)
    // - CI_IMAGE_NAME (imagen construida desde devops/ci.Dockerfile para usar `make`)
    // - (opcional E7) REGISTRY y REGISTRY_CREDS_ID
    // - (opcional E10) VERSION_JAR para cd.Dockerfile
  }

  stages {
    // =========================
    // Ejercicio 1 (estructura básica)
    // =========================
    stage('Info') {
      steps {
        // TODO (E1): imprime JOB_NAME y BUILD_NUMBER
      }
    }

    // =========================
    // Ejercicio 3 (preparación): construir imagen CI con make
    // =========================
    stage('CI - Build tools image') {
      steps {
        script {
          // TODO (E3): Construye una imagen de CI desde devops/ci.Dockerfile.
          // Ejemplo:
          // env.CI_IMAGE_NAME = "java-ci-tools:${env.BUILD_NUMBER}"
          // docker.build(env.CI_IMAGE_NAME, "-f devops/ci.Dockerfile .")
        }
      }
    }

    // =========================
    // Ejercicio 3 (lint/test con Makefile) + Ejercicio 4 (refactor con runInDocker)
    // =========================
    stage('CI - Lint') {
      steps {
        script {
          // TODO (E3/E4): Ejecuta `make lint` dentro de la imagen CI construida.
          // runInDocker(env.CI_IMAGE_NAME) { sh 'make lint' }
        }
      }
    }

    stage('CI - Test') {
      steps {
        script {
          // TODO (E3/E4): Ejecuta `make test` dentro de la imagen CI construida.
          // runInDocker(env.CI_IMAGE_NAME) { sh 'make test' }
        }
      }
    }

    // =========================
    // Ejercicio 5 (docker build)
    // =========================
    stage('CI - Build image') {
      steps {
        script {
          // TODO (E5): Construye la imagen Docker usando el Dockerfile del repo:
          // docker.build(env.IMAGE_NAME, "--build-arg VERSION=... -f devops/Dockerfile .")
        }
      }
    }

    // =========================
    // Ejercicio 8 (opcional, Java): subir jar a Artifactory con curl (sin plugin)
    // =========================
    stage('CI - Upload jar (opcional)') {
      when {
        // TODO (E8): Ejecuta solo si añades un parámetro tipo ENABLE_ARTIFACTORY_UPLOAD
      }
      steps {
        script {
          // TODO (E8): Usa withCredentials + curl para subir target/*.jar a Artifactory.
        }
      }
    }

    // =========================
    // Ejercicio 7 (opcional): push a registry privado
    // =========================
    stage('CI - Push image (opcional)') {
      when {
        // TODO (E7): Ejecuta solo si has añadido un parámetro tipo ENABLE_REGISTRY_PUSH
      }
      steps {
        script {
          // TODO (E7): Taggea y pushea la imagen a local-registry:5000 usando credenciales Jenkins.
        }
      }
    }

    // =========================
    // Ejercicio 6 (compose) + Ejercicio 6.1 (solo develop/master) + Ejercicio 6.3 (RUN_CD)
    // =========================
    stage('CD') {
      when {
        allOf {
          anyOf {
            branch 'develop'
            branch 'master'
          }
          // TODO (E6.3): Solo ejecutar CD si RUN_CD es true
        }
      }
      steps {
        script {
          // TODO (E6.2): Define DEPLOY_ENV (develop=DEV, master=PRO) y muestra logs.
          // TODO (E6): docker compose up -> logs -> docker compose down --volumes
          // Recomendado: encapsular con composeUpTestDown(...) (E9).
        }
      }
      post {
        // =========================
        // Ejercicio 6.5 (hooks post)
        // =========================
        always {
          // TODO (E6.5): Limpieza garantizada
        }
        success {
          // TODO (E6.5): SUCCESS
        }
        failure {
          // TODO (E6.5): FAILURE + logs
        }
      }
    }

    // =========================
    // Ejercicio 10 (opcional, Java): usar cd.Dockerfile en CD
    // =========================
    stage('CD - Build runtime image (opcional)') {
      when {
        // TODO (E10): Condición (por ejemplo, solo develop/master y RUN_CD true)
      }
      steps {
        script {
          // TODO (E10): docker build -f devops/cd.Dockerfile --build-arg VERSION=<version> .
        }
      }
    }
  }

  post {
    // Post global del pipeline (opcional)
  }
}
